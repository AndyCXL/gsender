import React, { useState, useEffect, useRef } from 'react';
import PropTypes from 'prop-types';
import pubsub from 'pubsub-js';

import store from 'app/store';
import Modal from 'app/components/Modal';
import { METRIC_UNITS } from 'app/constants';
import controller from 'app/lib/controller';

import InputArea from './InputArea';
import ActionArea from './components/actions';
import Visualizer from './components/visualizer';

import styles from './index.styl';


/**
 * @component Surfacing
 * @description Main component for displaying the Surfacing modal
 * @prop {Function} modalClose - Function to close the current modal
 */
const Surfacing = ({ modalClose }) => {
    const visualizerRef = useRef();

    const [surfacing, setSurfacing] = useState({
        bitDiameter: 22,
        stepover: 40,
        feedrate: 1500,
        length: 300,
        width: 200,
        skimDepth: 1,
        spindleRPM: 17000,
        maxDepth: 1,
    });

    const [gcode, setGcode] = useState('');
    const [units, setUnits] = useState(METRIC_UNITS);

    /**
     * Grab the set machine profile and workspace units on component mount
     */
    useEffect(() => {
        const machineProfile = store.get('workspace.machineProfile');
        const workspaceUnits = store.get('workspace.units');

        if (workspaceUnits) {
            setUnits(workspaceUnits);
        }

        if (machineProfile) {
            let length, width, skimDepth, stepover;

            if (workspaceUnits === METRIC_UNITS) {
                length = machineProfile.mm.depth;
                width = machineProfile.mm.width;
                skimDepth = 1;
                stepover = 40;
            } else {
                length = machineProfile.in.depth;
                width = machineProfile.in.width;
                skimDepth = 0.04;
                stepover = 2;
            }
            setSurfacing(prev => ({ ...prev, length, width, skimDepth, stepover }));
        }
    }, []);

    const handleChange = (e) => {
        const { id, value, min, max } = e.target;
        const val = Number(value);
        const minVal = Number(min);
        const maxVal = Number(max);

        if (!val || val < 0) {
            if (val !== 0) {
                return;
            }
        }
        if (min && val < minVal) {
            return;
        }
        if (max && val > maxVal) {
            return;
        }

        //Value may not exceed 3 decimal places
        let cleanedValue = val;
        if ([...val.toString()].length > 4) { //Value spread into the array includes the decimal dot
            cleanedValue = Number(cleanedValue.toFixed(3));
        }

        setSurfacing(prev => ({ ...prev, [id]: cleanedValue }));
    };

    /**
     * Main function to generate gcode
     */
    const handleGenerate = () => {
        const { skimDepth, maxDepth, feedrate, spindleRPM } = surfacing;

        let wcs = controller.state?.parserstate?.modal?.wcs || 'G54';

        let depth = skimDepth;
        let gCodeArr = [
            '(Header)',
            '(Generated by gSender from Sienci Labs)',
            wcs,
            units === METRIC_UNITS ? 'G21 ;mm' : 'G20 ;inches',
            'G90',
            'G0 X0 Y0',
            `G1 F${feedrate}`,
            `M3 S${spindleRPM}`,
            '(Header End)',
        ];
        let count = 1;

        const processGcode = (obj) => {
            const generatedArr = generateGcode({ depth: obj.depth, count: obj.count });
            gCodeArr.push(...generatedArr);
            count++;
            depth += skimDepth;
        };

        //Skip loop if there is only 1 layer
        if (depth === maxDepth) {
            processGcode({ depth: maxDepth, count });
        } else {
            // eslint-disable-next-line no-constant-condition
            while (true) {
                const remainder = maxDepth % depth;

                //If we reach the max depth, use it as the final depth value
                //(which would be the remainder) and exit the loop
                if (maxDepth === remainder && maxDepth - remainder === 0) {
                    processGcode({ depth: maxDepth, count });
                    break;
                } else {
                    processGcode({ depth, count });
                }
            }
        }
        gCodeArr.push(
            '\n',
            '(Footer)',
            'M5 ;Turn off spindle',
            '(Footer End)'
        );

        //Convert to string for visualizer to interperate it
        const gCodeArrStr = gCodeArr.reduce((str, current) => {
            return `${str}${current}\n`;
        }, '');

        visualizerRef.current.actions.loadGCode('gcode', gCodeArrStr);

        setGcode(gCodeArrStr);
    };

    /**
     * Function to generate gcode array
     * @param {number} depth - Depth value for Z axis
     * @param {number} count - Count value keeping track of the number of layers
     * @returns {array} - Returns the generated gcode set in an array
     */
    const generateGcode = ({ depth, count }) => {
        const {
            bitDiameter,
            stepover,
            length,
            width,
            maxDepth
        } = surfacing;

        const stepoverAmount = bitDiameter * (stepover / 100);

        const gCodeArr = [];

        const options = {
            depth,
            length,
            width,
            count,
            stepoverAmount,
            maxDepth
        };

        const traversed = draw(options);

        gCodeArr.push(...traversed);

        return gCodeArr;
    };

    /**
     * Function to draw a square spiral
     * @param {number} depth - Depth value for Z axis
     * @param {number} maxDepth - Maximum depth specified, this determines the number of layers to cut
     * @param {number} length - Length of machine (Y axis)
     * @param {number} width - Width of machine (X axis)
     * @param {number} count - Count value keeping track of the number of layers
     * @param {number} stepoverAmount - Space between each square spiral
     * @returns {array} - Returns the generated gcode set in an array
     */
    const draw = ({ depth, maxDepth, length, width, count, stepoverAmount }) => {
        const gCodeArr = [];

        const fixedVal = (val) => Number(val.toFixed(3));

        const Z = depth * -1;

        let currentPos = {
            X: stepoverAmount * 2,
            Y: stepoverAmount * 2,
        };

        let endPos = {
            X: width - stepoverAmount,
            Y: length - stepoverAmount
        };

        //Draw initial full rectangle covering full length and width of the machine

        if (maxDepth === depth) {
            gCodeArr.push(`(Layer ${count})`);
        }
        gCodeArr.push(
            `G1 Z${fixedVal(Z)}`,
            `G1 Y${fixedVal(length)}`,
            `G1 X${fixedVal(width)}`,
            'G1 Y0',
            'G1 X0',
            `G1 X${fixedVal(stepoverAmount)} Y${fixedVal(stepoverAmount)}`,
        );

        // eslint-disable-next-line no-constant-condition
        while (true) {
            if (endPos.X <= currentPos.X || endPos.Y <= currentPos.Y) {
                break;
            }

            //Full rectangualar movement from up => right => bottom => left
            gCodeArr.push(
                '\n',
                `G1 Y${fixedVal(endPos.Y)}`,
                `G1 X${fixedVal(endPos.X)}`,
                `G1 Y${fixedVal(currentPos.Y)}`,
                `G1 X${fixedVal(currentPos.X)}`,
            );

            const newCurrentPosX = Number(fixedVal(endPos.X - stepoverAmount));
            const newCurrentPosY = Number(fixedVal(endPos.Y - stepoverAmount));
            const newEndPosX = Number(fixedVal(currentPos.X + stepoverAmount));
            const newEndPosY = Number(fixedVal(currentPos.Y + stepoverAmount));

            //New position will be the previous end position minus the stepover amount
            const newPos = {
                X: newCurrentPosX,
                Y: newCurrentPosY,
            };

            //New end position will be the previous position plus the stepover amount
            const newEndPos = {
                X: newEndPosX,
                Y: newEndPosY,
            };

            currentPos = Object.assign({}, newEndPos);
            endPos = Object.assign({}, newPos);
        }

        gCodeArr.push(
            `G0 Z${Math.abs(Z)}`,
            'G0 X0 Y0',
        );
        if (maxDepth === depth) {
            gCodeArr.push(`(End of Layer ${count})`);
        }

        return gCodeArr;
    };

    /**
     * Function to load generated gcode to main visualizer
     */
    const loadGcode = () => {
        modalClose();
        const name = 'gSender_Surfacing';
        pubsub.publish('gcode:surfacing', { gcode, name, size: (gcode.length * 2) });
    };

    /**
     * Function to clear generated gcode
     */
    const clear = () => {
        setGcode('');
        visualizerRef.current.actions.reset();
    };

    const canLoad = !!gcode; //For accessing the gcode line viewer

    return (
        <Modal onClose={modalClose} size="lg" disableOverlay>
            <div className={styles.header}>
                <h3 className={styles.headerText}>Surfacing Tool</h3>
            </div>

            <div className={styles.container}>
                <div className={styles.mainContainer}>
                    <InputArea values={surfacing} onChange={handleChange} units={units} />
                    <Visualizer
                        widgetId="visualizer"
                        ref={visualizerRef}
                        gcode={gcode}
                    />
                    <div>
                        <p style={{ marginTop: '1rem' }}>
                            <strong>Instructions: </strong>
                            Position your machine to the front left side of your machine and set it as your zero point
                        </p>
                        <p style={{ marginBottom: 0 }}>
                            <strong>Note: </strong>
                            If you have any additional hardware installed on your machine (ex. dust shoe),{' '}
                            it may be limited in reaching the maximum x or y axis
                        </p>
                    </div>
                </div>

                <ActionArea
                    handleCancel={modalClose}
                    handleClear={clear}
                    handleGenerateGcode={handleGenerate}
                    handleLoadGcode={loadGcode}
                    surfacing={surfacing}
                    canLoad={canLoad}
                />
            </div>
        </Modal>
    );
};

Surfacing.propTypes = {
    state: PropTypes.object,
    modalClose: PropTypes.func.isRequired,
};

export default Surfacing;
