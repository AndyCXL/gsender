import Toolpath from 'gcode-toolpath';

import store from 'app/store';
import {
    METRIC_UNITS,
    SPIRAL_MOVEMENT,
    ZIG_ZAG_MOVEMENT,
    START_POSITION_BACK_LEFT,
    START_POSITION_BACK_RIGHT,
    START_POSITION_FRONT_LEFT,
    START_POSITION_FRONT_RIGHT,
} from 'app/constants';
import { convertToImperial } from '../../Preferences/calculate';

export default class Generator {
    constructor({ surfacing, units, controller, rampingDegrees = 10 }) {
        this.surfacing = surfacing;
        this.units = units;
        this.controller = controller;
        this.rampingDegrees = rampingDegrees;
    }

    /**
     * Main function to generate gcode
     */
    handleGenerate = () => {
        const { surfacing, controller, units, generateGcode } = this;
        const { skimDepth, maxDepth, feedrate, spindleRPM, spindle = 'M3' } = surfacing;

        let wcs = controller.state?.parserstate?.modal?.wcs || 'G54';

        let depth = skimDepth;
        let gCodeArr = [
            '(Header)',
            '(Generated by gSender from Sienci Labs)',
            wcs,
            units === METRIC_UNITS ? 'G21 ;mm' : 'G20 ;inches',
            'G90',
            'G0 X0 Y0',
            `G1 F${feedrate}`,
            `${spindle} S${spindleRPM}`,
            '(Header End)',
            '\n'
        ];
        let count = 1;

        function processGcode(obj) {
            const generatedArr = generateGcode({ depth: obj.depth, count: obj.count });
            gCodeArr.push(...generatedArr);
            count++;
            depth += skimDepth;
        }

        //Skip loop if there is only 1 layer
        if (depth === maxDepth) {
            processGcode({ depth: maxDepth, count });
        } else {
            // eslint-disable-next-line no-constant-condition
            while (true) {
                const remainder = maxDepth % depth;

                //If we reach the max depth, use it as the final depth value
                //(which would be the remainder) and exit the loop
                if (maxDepth === remainder && maxDepth - remainder === 0) {
                    processGcode({ depth: maxDepth, count });
                    break;
                } else {
                    processGcode({ depth, count });
                }
            }
        }
        gCodeArr.push(
            '\n',
            '(Footer)',
            'M5 ;Turn off spindle',
            '(Footer End)'
        );

        const gCodeArrStr = gCodeArr.join('\n');

        return gCodeArrStr;
    };

    /**
     * Function to generate gcode array
     * @param {number} depth - Depth value for Z axis
     * @param {number} count - Count value keeping track of the number of layers
     * @returns {array} - Returns the generated gcode set in an array
     */
    generateGcode = ({ depth, count }) => {
        const {
            bitDiameter,
            stepover,
            length,
            width,
            maxDepth,
            startPosition,
            type,
            startFromCenter
        } = this.surfacing;

        const stepoverAmount = this.toFixedValue(bitDiameter * (stepover / 100));

        const DEFAULT_FACTOR = { x: 1, y: -1 };

        const axisFactors = {
            [START_POSITION_BACK_LEFT]: { x: 1, y: -1 },
            [START_POSITION_BACK_RIGHT]: { x: -1, y: -1 },
            [START_POSITION_FRONT_LEFT]: { x: 1, y: 1 },
            [START_POSITION_FRONT_RIGHT]: { x: -1, y: 1 },
        }[startPosition] ?? DEFAULT_FACTOR;

        const options = {
            depth,
            length,
            width,
            count,
            stepoverAmount,
            maxDepth,
            axisFactors,
            startFromCenter
        };

        const surfacingTypeFunction = {
            [SPIRAL_MOVEMENT]: this.generateSpiral,
            [ZIG_ZAG_MOVEMENT]: this.generateZigZag
        }[type];

        const gcodeArr = surfacingTypeFunction(options);

        return gcodeArr;
    };

    toFixedValue(value = 0, amount = 3) {
        return Number(value.toFixed(amount));
    }

    enterIntoMaterial = (z, direction = { axis: 'Y', factor: 1 }) => {
        const { axis, factor } = direction;
        const RAMP_THRESHOLD = 30;
        const degrees = this.rampingDegrees;
        const { skimDepth, feedrate } = this.surfacing;
        const units = store.get('workspace.units');
        const depth = skimDepth;
        const extraLength = units === METRIC_UNITS ? 1 : convertToImperial(1);
        const rampingLength = Number(((depth + extraLength) / getTanFromDegrees(degrees)).toFixed(2));
        const halfOfFeedrate = Math.round((feedrate / 2));
        const MAX_RAMP_AMOUNT = units === METRIC_UNITS ? RAMP_THRESHOLD : convertToImperial(RAMP_THRESHOLD);

        function getTanFromDegrees(degrees) {
            return Math.tan(degrees * Math.PI / 180);
        }

        const rampingArr = [];

        rampingLength < MAX_RAMP_AMOUNT
            ? rampingArr.push(
                '(Plunging into Material)',
                `G1 Z${z}`,
                '(End of Plunging into Material)',
                ''
            )
            : rampingArr.push(
                '(Ramping into Material)',
                'G91',
                `G1 ${axis}${rampingLength * factor}`,
                `G1 ${axis}${(rampingLength * factor) * -1} Z${z} F${halfOfFeedrate}`, //Negate and return to starting position
                `G0 F${feedrate}`, // Set back to regular feedrate
                'G90', //Set back to absolute positioning
                '(End of Ramping into Material)',
                ''
            );

        return rampingArr;
    }

    drawInitialPerimeter = (x, y, z, direction, shouldZeroAxisZ = true) => {
        const enterMaterial = this.enterIntoMaterial(z, direction);

        return [
            '(Covering Surfacing Perimeter)',
            ...enterMaterial,
            `G1 Y${y}`,
            `G1 X${x}`,
            'G1 Y0',
            'G1 X0',
            ...(shouldZeroAxisZ ? ['G1 Z0'] : []),
            '(End of Covering Surfacing Perimeter)',
            ''
        ];
    }

    enterSpiralStartArea(x, y, singleMovement = false, movementType = 'G1') {
        const movement = singleMovement
            ? [`${movementType} X${x} Y${y}`]
            : [`${movementType} X${x}`, `${movementType} Y${y}`];

        return [
            '(Entering Start Position)',
            ...movement,
            '(End of Entering Start Position)',
            ''
        ];
    }

    getSafeZValue() {
        const workspaceUnits = store.get('workspace.units');
        const Z_VALUE = workspaceUnits === METRIC_UNITS ? '3' : '0.12';

        return Z_VALUE;
    }

    returnToZero = () => {
        const z = this.getSafeZValue();

        return [
            '(Returning to Zero)',
            `G0 Z${z}`,
            'G0 X0 Y0',
            '(End of Returning to Zero)',
            ''
        ];
    }

    generateSpiral = (options) => {
        const { drawInitialPerimeter, enterSpiralStartArea, drawSpiral, returnToZero, enterIntoMaterial } = this;
        const { depth, length, width, axisFactors, count, stepoverAmount, startFromCenter } = options;
        const { x: xFactor, y: yFactor } = axisFactors;

        const x = this.toFixedValue(width * xFactor);
        const y = this.toFixedValue(length * yFactor);
        const z = this.toFixedValue(depth * -1);

        const startPos = {
            x: this.toFixedValue(stepoverAmount),
            y: this.toFixedValue(stepoverAmount),
        };

        const endPos = {
            x: this.toFixedValue(width - stepoverAmount),
            y: this.toFixedValue(length - stepoverAmount),
        };

        const direction = {
            axis: 'Y',
            factor: axisFactors.y,
        };

        if (width >= length) {
            direction.axis = 'X';
            direction.factor = axisFactors.x;
        }

        const initialPerimeter = drawInitialPerimeter(x, y, z, direction);
        const spirals = drawSpiral([], startPos, endPos, options);
        const returnToStart = returnToZero();

        // This is the area that is not accounted for due to the positioning of the gcode when starting from the center
        // (Easiest way to do this would be to generaete the spiral array and reverse it)
        const remainder = [
            '(Covering Remaining Area)',
            `G1 X${this.toFixedValue((stepoverAmount) * xFactor)}`,
            `G1 Y${this.toFixedValue(0)}`,
            '(End of Covering Remaining Area)',
            ''
        ];

        const toolpath = new Toolpath();
        toolpath.loadFromStringSync(spirals.join('\n'));
        const position = toolpath.getPosition();

        const mainSpiralArea = [];

        if (startFromCenter) {
            mainSpiralArea.push(
                enterSpiralStartArea(position.x, position.y, true, 'G0'),
                enterIntoMaterial(z, direction),
                spirals.reverse(),
                remainder
            );
        } else {
            mainSpiralArea.push(
                enterSpiralStartArea(stepoverAmount * xFactor, stepoverAmount * yFactor, false),
                enterIntoMaterial(z, direction),
                spirals
            );
        }

        /**
         * 1. Draw initial surfacing area perimeter
         * 2. Move to the start area
         * 3. Begin drawing spiral recursively
         * 4. End of spiral, move z axis up and return to the zero position
         **/
        const gcodeArr = [
            `(*** Layer ${count} ***)`,
            ...initialPerimeter,
            ...mainSpiralArea.flat(),
            ...returnToStart,
            `(*** End of Layer ${count} ***)`
        ];

        return gcodeArr;
    }

    drawSpiral = (arr, startPos, endPos, options) => {
        const { toFixedValue, drawSpiral } = this;
        const { axisFactors, stepoverAmount } = options;
        const { x: xFactor, y: yFactor } = axisFactors;

        if (endPos.x <= startPos.x || endPos.y <= startPos.y) {
            return arr;
        }

        /** Splitting the line segments will cover the cases where the spiral should only cover either or axes
         *  Ex. Remaining area at the center just needs to cover the horizontal (x axis) area
         */
        if (endPos.y >= startPos.y) {
            arr.push(`G1 Y${toFixedValue(endPos.y * yFactor)}`);
        }

        if (endPos.x >= startPos.x) {
            arr.push(`G1 X${toFixedValue(endPos.x * xFactor)}`);
        }

        if (endPos.x > startPos.x && endPos.y > startPos.y) {
            arr.push(
                `G1 Y${toFixedValue(startPos.y * yFactor)}`,
                `G1 X${(toFixedValue(startPos.x + stepoverAmount) * xFactor)}`,
                ''
            );
        } else {
            arr.push('');
        }

        const nextStartPos = {
            x: toFixedValue(startPos.x + stepoverAmount),
            y: toFixedValue(startPos.y + stepoverAmount)
        };
        const nextEndPos = {
            x: toFixedValue(endPos.x - stepoverAmount),
            y: toFixedValue(endPos.y - stepoverAmount)
        };

        return drawSpiral(arr, nextStartPos, nextEndPos, options);
    }

    generateZigZag = (options) => {
        const { depth, length, width, axisFactors, count, stepoverAmount } = options;
        const { x: xFactor, y: yFactor } = axisFactors;

        const x = this.toFixedValue(width * xFactor);
        const y = this.toFixedValue(length * yFactor);
        const z = this.toFixedValue(depth * -1);

        const startPos = {
            x: width,
            y: this.toFixedValue(stepoverAmount),
        };

        const endPos = {
            x: 0,
            y: this.toFixedValue(stepoverAmount * 2),
        };

        const { drawInitialPerimeter, drawZigZag, returnToZero } = this;

        const direction = {
            axis: 'Y',
            factor: axisFactors.y,
        };

        if (width >= length) {
            direction.axis = 'X';
            direction.factor = axisFactors.x;
        }

        /**
         * 1. Draw initial surfacing area perimeter and do not zero z axis
         * 2. Begin drawing zig zag recursively
         * 4. End of zig zag, move z axis up and return to the zero position
         **/
        const gcodeArr = [
            `(*** Layer ${count} ***)`,
            ...drawInitialPerimeter(x, y, z, direction, false),
            ...drawZigZag([], startPos, endPos, options),
            ...returnToZero(),
            `(*** End of Layer ${count} ***)`
        ];

        return gcodeArr;
    }

    drawZigZag = (arr, startPos, endPos, options) => {
        const { axisFactors, stepoverAmount, length } = options;
        const { x: xFactor, y: yFactor } = axisFactors;
        const { toFixedValue, drawZigZag } = this;

        if (startPos.y >= length) {
            return arr;
        }

        arr.push(
            `G1 X${startPos.x * xFactor}`,
            `G1 Y${this.toFixedValue(startPos.y * yFactor)}`,
            `G1 X${this.toFixedValue(endPos.x * yFactor)}`,
            `G1 Y${this.toFixedValue(endPos.y * yFactor)}`,
        );

        const nextStartPos = {
            x: startPos.x,
            y: toFixedValue(startPos.y + stepoverAmount)
        };
        const nextEndPos = {
            x: endPos.x,
            y: toFixedValue(endPos.y + stepoverAmount)
        };

        return drawZigZag(arr, nextStartPos, nextEndPos, options);
    }
}
